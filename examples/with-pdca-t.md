# IRIS Example: Integration with PDCA-T
## Coverage Escalation — Breaking Through the 87% Ceiling

**Scenario:** A Node.js payments module developed with PDCA-T. After 3 cycles, test coverage is stuck at 87%. PDCA-T escalates to IRIS.

**IDE:** Claude Code | **Methods:** PDCA-T + IRIS

---

## Context

The payments processor has this structure:
```
src/payments/
├── processor.js      (280 LOC — business logic + direct HTTP)
├── validator.js      (95 LOC — input validation)
└── logger.js         (45 LOC — structured logging)
```

PDCA-T has achieved:
- Cycle 1: 72% coverage
- Cycle 2: 82% coverage (added edge case tests)
- Cycle 3: 87% coverage (added retry logic tests)
- Cycle 4 attempted: 87% — stuck. Error paths in HTTP failure scenarios are untestable.

---

## IRIS_INPUT.json (generated by PDCA-T)

```json
{
  "schema_version": "2.1.0",
  "source_method": "pdca-t",
  "trigger_reason": "coverage-escalation",
  "context": {
    "repository_path": "./src/payments/",
    "previous_cycle_number": 0,
    "iris_log_path": "IRIS_LOG.md"
  },
  "current_metrics": {
    "test_coverage": 87,
    "defect_density": 1.8
  },
  "escalation_data": {
    "attempts_made": 3,
    "target_coverage": 99,
    "achieved_coverage": 87,
    "failure_reason": "HTTP error paths in processor.js are not testable because the module calls fetch() directly. Network failures, timeout scenarios, and non-200 responses cannot be reliably triggered in tests without a real network.",
    "problematic_modules": [
      {
        "path": "src/payments/processor.js",
        "coverage": 71,
        "issue": "Lines 145–198 (HTTP call and all error branches) — 0% coverage"
      }
    ]
  },
  "artifacts": [
    { "type": "source-code", "path": "src/payments/processor.js", "criticality": "high" },
    { "type": "test-file", "path": "tests/payments/processor.test.js", "criticality": "high" },
    { "type": "coverage-report", "path": "coverage/lcov-report/index.html", "criticality": "medium" }
  ],
  "requested_focus": ["test-coverage", "architecture"],
  "timestamp": "2026-02-20T14:30:00Z"
}
```

---

## IRIS Session

### Command: `IRIS: analyze src/payments/`

**IRIS reads IRIS_INPUT.json → detects coverage-escalation from pdca-t**

---

### IRIS Fase 1 Report — Context Acquisition (Focused)
**Cycle:** #1 | **Source:** pdca-t escalation

Reading `src/payments/processor.js` (lines 1–280)...

**Finding:** `processor.js` has this structure:
```javascript
// Lines 130–200: the problematic section
async function processPayment(payment) {
  const validated = validatePayment(payment)     // covered
  const response = await fetch(PAYMENT_API_URL, { // direct fetch call
    method: 'POST',
    body: JSON.stringify(validated)
  })
  
  if (response.status === 200) {                  // branch: 100% covered
    return await response.json()
  } else if (response.status === 422) {           // branch: 0% — can't fake HTTP 422
    throw new ValidationError(await response.json())
  } else if (response.status === 429) {           // branch: 0% — can't fake rate limiting
    await sleep(1000)
    return processPayment(payment)                // retry — 0% coverage
  } else {
    throw new PaymentError(`Unexpected: ${response.status}`)
  }
}
```

**Root cause identified:** `fetch()` is called directly. There is no way to inject a mock. Tests cannot simulate HTTP 422, 429, or network errors without a real server or complex test infrastructure.

**Integration points detected:** PDCA-T rule file present → escalation context confirmed.

---

### IRIS Fase 2 Report — Quality Assessment (Focused on Testability)

**Primary finding (root cause):**

| ID | File | Lines | Issue | Category |
|----|------|-------|-------|----------|
| C-001 | processor.js | 145–198 | Direct `fetch()` call with no injection point — prevents mocking HTTP responses | IMPROVABLE |
| C-002 | processor.js | 180–198 | Retry logic embedded in business function — untestable in isolation | IMPROVABLE |

**Why PDCA-T couldn't solve this:**
PDCA-T can write tests, but it cannot make untestable code testable. The architectural coupling between business logic and HTTP is the blocker — not test writing skill.

**Secondary findings:**
- `processor.js` violates SRP: it handles business logic + HTTP communication + retry logic
- No `PaymentGateway` abstraction exists — callers cannot be swapped for test doubles

**Metrics (relevant to escalation):**
| Metric | Value |
|--------|-------|
| Test Coverage | 87% (71% in processor.js) |
| Coverage Gap in processor.js | 28 percentage points |
| SOLID violations | 1 (SRP in processor.js) |

---

### IRIS Fase 3 Report — Improvement Roadmap (Architecture-Focused)

**Objective:** Make `processor.js` testable. Do NOT write tests — that's PDCA-T's job after handoff.

**Iteration 1: Extract HTTP Layer (Gateway Pattern)**
- Objective: Introduce a `PaymentGateway` interface between business logic and HTTP
- Files:
  - `src/payments/gateway.interface.js` (new — 35 LOC): define the interface
  - `src/payments/http-gateway.js` (new — 65 LOC): move `fetch()` logic here
  - `src/payments/processor.js` (modify — 45 LOC changed): use injected gateway
  - `tests/payments/processor.test.js` (update — 40 LOC): update to inject mock gateway
- LOC estimate: +140 / -30 (~170 total) ✅ ≤400
- Risk: MEDIUM — changes public interface of processPayment()
- Rollback: `git reset --hard iris-start-iter-1`
- DoD:
  - [ ] `gateway.interface.js` defines `PaymentGateway` contract
  - [ ] `http-gateway.js` implements `PaymentGateway` with the original `fetch()` logic
  - [ ] `processor.js` accepts gateway as constructor parameter with default = `HttpGateway`
  - [ ] Existing tests still pass (behavior unchanged)
  - [ ] New mock gateway can be created with 5 lines in a test

**Iteration 2: Extract Retry Logic**
- Objective: Separate retry behavior from payment processing
- Files: `src/payments/retry.js` (new — 55 LOC), `processor.js` (modify — 30 LOC)
- LOC estimate: +55 / -30 (~85 total) ✅ ≤400
- Risk: LOW
- DoD: [ ] `retry.js` has its own tests | [ ] processor.js uses retry utility

---

### IRIS Fase 4 — Iteration 1: Extract Gateway

**Pre-flight:** git clean ✅ | Tag: `iris-start-iter-1` created

**gateway.interface.js** (new file — 35 LOC):
```javascript
/**
 * PaymentGateway defines the contract for payment processor communication.
 * Implementations: HttpGateway (production), MockGateway (tests).
 */
class PaymentGateway {
  async charge(payload) {
    throw new Error('Not implemented')
  }
}

module.exports = { PaymentGateway }
```

**http-gateway.js** (extracted from processor.js — 65 LOC):
```javascript
const { PaymentGateway } = require('./gateway.interface')

class HttpGateway extends PaymentGateway {
  constructor(apiUrl = process.env.PAYMENT_API_URL) {
    super()
    this.apiUrl = apiUrl
  }

  async charge(payload) {
    const response = await fetch(this.apiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
    return { status: response.status, body: await response.json() }
  }
}

module.exports = { HttpGateway }
```

**processor.js** (modified — accepts injected gateway):
```javascript
const { HttpGateway } = require('./http-gateway')

class PaymentProcessor {
  constructor(gateway = new HttpGateway()) {
    this.gateway = gateway          // injectable — test doubles can be passed here
  }

  async processPayment(payment) {
    const validated = validatePayment(payment)
    const result = await this.gateway.charge(validated)  // no more direct fetch()
    
    if (result.status === 200) return result.body
    if (result.status === 422) throw new ValidationError(result.body)
    if (result.status === 429) {
      await sleep(1000)
      return this.processPayment(payment)  // retry — now mockable
    }
    throw new PaymentError(`Unexpected status: ${result.status}`)
  }
}
```

**Tests updated to verify gateway injection works:**
```javascript
// Existing test verifying interface is unchanged:
const processor = new PaymentProcessor(new HttpGateway())
// ... test with real gateway (integration test)
```

**Test results:**
```
npm test
  PaymentProcessor
    ✓ processes valid payment (existing test) — PASSES ✅
    ✓ rejects invalid payment (existing test) — PASSES ✅
  12 tests, 12 passed, 0 failed
```

Coverage: 87% → 88% (gateway extraction added 1%)

**Commits:**
- `abc1234` IRIS-iter-1: Extract PaymentGateway interface
- `def5678` IRIS-iter-1: Move HTTP logic to HttpGateway class
- `ghi9012` IRIS-iter-1: Refactor processor to use injected gateway

Iteration 1 DoD: All 4 criteria verified ✅

---

### IRIS Fase 5 — Verification + Handoff to PDCA-T

**Regression test:** 12 tests, 12 passed ✅

**Architecture change verified:**
- `processor.js` no longer imports `fetch` directly ✅
- `PaymentGateway` interface defined ✅
- Tests can now inject `MockGateway` in 5 lines ✅

**IRIS_OUTPUT.json generated:**
```json
{
  "schema_version": "2.1.0",
  "cycle_number": 1,
  "target_method": "pdca-t",
  "next_action": "handoff-to-pdca-t",
  "metrics_before": { "test_coverage": 87, "defect_density": 1.8 },
  "metrics_after": { "test_coverage": 88, "defect_density": 1.6 },
  "pdca_t_handoff": {
    "refactored_modules": [
      "src/payments/processor.js — gateway injection introduced",
      "src/payments/http-gateway.js — new concrete implementation",
      "src/payments/gateway.interface.js — new interface"
    ],
    "new_interfaces": ["PaymentGateway (src/payments/gateway.interface.js)"],
    "expected_coverage_after_pdca": 99
  },
  "handoff_context": {
    "focus_areas": [
      "Create MockGateway that returns configurable status codes",
      "Test all HTTP status paths: 200, 422, 429, unexpected (500)",
      "Test retry behavior by returning 429 then 200"
    ],
    "avoided_pitfalls": [
      "Do not try to test HttpGateway with real network — that is an integration test"
    ],
    "urgent_attention": []
  }
}
```

---

## PDCA-T Resumes (after IRIS handoff)

With the gateway abstraction in place, PDCA-T writes the previously impossible tests:

```javascript
// MockGateway — 8 lines:
class MockGateway {
  constructor(responses) { this.responses = responses; this.index = 0 }
  async charge() { return this.responses[this.index++] }
}

// Test: HTTP 422 path (was 0% before IRIS):
test('throws ValidationError on 422', async () => {
  const gateway = new MockGateway([{ status: 422, body: { error: 'invalid card' } }])
  const processor = new PaymentProcessor(gateway)
  await expect(processor.processPayment(validPayment)).rejects.toThrow(ValidationError)
})

// Test: retry on 429 then success (was 0% before IRIS):
test('retries once on 429 then succeeds', async () => {
  const gateway = new MockGateway([
    { status: 429, body: {} },
    { status: 200, body: { transactionId: 'tx-123' } }
  ])
  const processor = new PaymentProcessor(gateway)
  const result = await processor.processPayment(validPayment)
  expect(result.transactionId).toBe('tx-123')
})
```

**PDCA-T Cycle 4 result:** Coverage 87% → **99.4%** ✅

**Key takeaway:** IRIS solved the architectural problem (untestable coupling). PDCA-T solved the quality problem (missing tests). Each method did what it does best.
